### BEGIN FILE: .github/workflows/ci-dashboard.yml
name: CI - Dashboard Script Tests

on:
  push:
    paths:
      - '**/*.ps1'
  workflow_dispatch:

jobs:
  lint-and-unit-tests:
    name: lint-and-unit-tests (pwsh ${{ matrix.pwsh }})
    runs-on: windows-latest
    strategy:
      fail-fast: false
      matrix:
        include:
          - pwsh: '7.4.x'   # preinstalled on windows-latest (Windows Server 2025)
            install: false
          - pwsh: '7.2.x'   # keep an “old engine” leg for compat
            install: true

    defaults:
      run:
        shell: pwsh

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Compute paths once and expose as outputs for later steps
      - name: Discover script & module path
        id: discover
        run: |
          Set-StrictMode -Version Latest
          $ErrorActionPreference = 'Stop'

          # Find the dashboard script anywhere in the repo
          $script = Get-ChildItem -Path $PWD -Filter 'SystemDashboard.ps1' -Recurse -File -ErrorAction Stop |
                    Select-Object -First 1 -ExpandProperty FullName

          if (-not $script) {
            throw "Could not find 'SystemDashboard.ps1' anywhere under $PWD. Adjust the filter or rename."
          }

          # Where user-scoped modules live on Windows runners
          $modulePath = Join-Path $env:USERPROFILE 'Documents\PowerShell\Modules'

          "script_path=$script"     | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          "module_cache=$modulePath"| Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8

          Write-Host "Script: $script"
          Write-Host "Module cache: $modulePath"

      - name: Cache PowerShell modules
        uses: actions/cache@v4
        with:
          path: ${{ steps.discover.outputs.module_cache }}
          key: psmodules-${{ runner.os }}-${{ hashFiles('**/*.psd1') }}
          restore-keys: |
            psmodules-${{ runner.os }}-

      # Install 7.2.x only; skip 7.4.x (already present)
      - name: Install PowerShell ${{ matrix.pwsh }} (retry)
        if: matrix.install == true
        uses: nick-fields/retry@v3
        with:
          timeout_minutes: 10
          max_attempts: 3
          command: |
            pwsh -NoProfile -Command "
              Set-StrictMode -Version Latest
              \$ErrorActionPreference = 'Stop'
              iex (irm 'https://raw.githubusercontent.com/PSModule/Install-PowerShell/main/install-latest.ps1')
              Install-PowerShell -Version '${{ matrix.pwsh }}' -Quiet -ErrorAction Stop
            "

      - name: Verify PowerShell version
        run: |
          'Using pwsh: ' + (Get-Command pwsh).Source
          $PSVersionTable.PSVersion

      - name: Install PSScriptAnalyzer (retry)
        uses: nick-fields/retry@v3
        with:
          timeout_minutes: 5
          max_attempts: 3
          command: |
            pwsh -NoProfile -Command "
              Set-StrictMode -Version Latest
              \$ErrorActionPreference = 'Stop'
              if (-not (Get-PSRepository -Name PSGallery).InstallationPolicy -eq 'Trusted') {
                Set-PSRepository -Name PSGallery -InstallationPolicy Trusted
              }
              Install-Module PSScriptAnalyzer -Scope CurrentUser -Force -ErrorAction Stop
            "

      - name: Lint with PSScriptAnalyzer
        run: |
          $scriptPath = '${{ steps.discover.outputs.script_path }}'
          Invoke-ScriptAnalyzer -Path $scriptPath -Recurse -Severity Warning,Error

      - name: Unit test Get-Metrics output shape
        run: |
          $script  = '${{ steps.discover.outputs.script_path }}'
          $metrics = & $script -Port 9000 -WanProbeHost '127.0.0.1' `
                               -DesiredDriveLetters '' `
                               -EventProvidersOfInterest '' `
                               -HotMessageKeywords '' `
                               -OpenBrowser:$false

          # --- Assertions ----------------------------------------------------
          if (-not ($metrics -is [pscustomobject])) { throw 'Get-Metrics did not return a PSCustomObject' }

          foreach ($prop in 'ComputerName','Timestamp','CPU','Memory','Disks','Network','Events','TopProcesses') {
            if (-not $metrics.PSObject.Properties.Name -contains $prop) { throw "Missing property: $prop" }
          }

          if (-not ($metrics.CPU.UsagePct -is [double] -or $metrics.CPU.UsagePct -is [int])) {
            throw 'CPU.UsagePct is not numeric'
          }

          Write-Host 'Metrics shape validated.'

      - name: Smoke test HTTP endpoint (poll, random port)
        run: |
          $script = '${{ steps.discover.outputs.script_path }}'
          $port   = Get-Random -Minimum 20000 -Maximum 40000

          # Paranoid: evict any prior listener on the chosen port
          Get-NetTCPConnection -LocalPort $port -State Listen -ErrorAction SilentlyContinue |
            Select-Object -ExpandProperty OwningProcess -Unique |
            ForEach-Object { Stop-Process -Id $_ -Force -ErrorAction SilentlyContinue }

          $proc = Start-Process -FilePath pwsh -ArgumentList @(
            '-NoProfile','-ExecutionPolicy','Bypass','-Command',
            "& { . `"$script`" -Port $port -WanProbeHost '127.0.0.1' -DesiredDriveLetters '' -EventProvidersOfInterest '' -HotMessageKeywords '' -OpenBrowser:`$false }"
          ) -PassThru

          try {
            $deadline = (Get-Date).AddSeconds(30)
            $ok = $false
            do {
              Start-Sleep -Seconds 1
              try {
                $r = Invoke-WebRequest -Uri \"http://localhost:$port/metrics\" -UseBasicParsing -TimeoutSec 3
                if ($r.StatusCode -eq 200) { $ok = $true }
              } catch { }
            } while (-not $ok -and (Get-Date) -lt $deadline)

            if (-not $ok) { throw \"Endpoint never returned 200 within 30s on port $port.\" }

            $json = $r.Content | ConvertFrom-Json
            if (-not $json.ComputerName) { throw 'JSON missing ComputerName' }

            Write-Host \"HTTP /metrics OK on port $port\"
          }
          finally {
            if ($proc -and -not $proc.HasExited) {
              Stop-Process -Id $proc.Id -Force -ErrorAction SilentlyContinue
            }
          }

      - name: Cleanup (ensure no lingering listeners)
        run: |
          # Sweep a couple of known ports just in case
          foreach ($p in 9000, 9111) {
            Get-NetTCPConnection -LocalPort $p -State Listen -ErrorAction SilentlyContinue |
              Select-Object -ExpandProperty OwningProcess -Unique |
              ForEach-Object { Stop-Process -Id $_ -Force -ErrorAction SilentlyContinue }
          }
### END FILE
