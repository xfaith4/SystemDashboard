{% extends 'base.html' %}
{% block title %}NOC Dashboard - System Events{% endblock %}
{% block content %}
<section class="page-container">
    <header class="dashboard-header">
        <div>
            <h1>System Events</h1>
            <p class="subtitle">Windows and router event log monitoring</p>
        </div>
        <div class="toolbar">
            <input id="searchInput" type="search" placeholder="Search messages, sources..." />
            <select id="levelFilter" title="Filter by event level">
                <option value="">All Levels</option>
                <option value="Error">Error</option>
                <option value="Warning">Warning</option>
                <option value="Information">Information</option>
            </select>
            <button class="btn-analyze-trends" id="analyzeTrendsBtn">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/>
                    <path d="M10 8v4l3 3"/>
                </svg>
                Analyze Trends
            </button>
            <button class="btn-refresh" id="refreshBtn">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="23 4 23 10 17 10"/>
                    <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"/>
                </svg>
                Refresh
            </button>
        </div>
    </header>

    <div id="data-source" class="info-banner hidden"></div>

    <!-- Log Type Selection -->
    <div class="log-type-filter">
        <label class="log-type-label">Event Logs:</label>
        <label class="checkbox-label">
            <input type="checkbox" id="logTypeApplication" checked />
            <span>Application</span>
        </label>
        <label class="checkbox-label">
            <input type="checkbox" id="logTypeSecurity" checked />
            <span>Security</span>
        </label>
        <label class="checkbox-label">
            <input type="checkbox" id="logTypeSystem" checked />
            <span>System</span>
        </label>
    </div>

    <!-- Stats Summary Cards -->
    <div class="kpi-grid">
        <article class="kpi-card">
            <h2>Total Events</h2>
            <p class="metric" id="stat-total">--</p>
            <p class="detail">Events loaded</p>
        </article>
        <article class="kpi-card">
            <h2>Auth / Login</h2>
            <p class="metric" id="stat-auth">--</p>
            <p class="detail">Authentication events</p>
        </article>
        <article class="kpi-card">
            <h2>Disk / IO</h2>
            <p class="metric" id="stat-disk">--</p>
            <p class="detail">Storage related</p>
        </article>
        <article class="kpi-card">
            <h2>Network</h2>
            <p class="metric" id="stat-net">--</p>
            <p class="detail">Network events</p>
        </article>
    </div>

    <!-- Charts Grid -->
    <div class="charts-grid">
        <section class="chart-card">
            <header class="chart-header">
                <h3>Severity Distribution</h3>
                <div class="range-selector">
                    <select id="rangeHours">
                        <option value="1">1h</option>
                        <option value="6">6h</option>
                        <option value="24" selected>24h</option>
                        <option value="72">3d</option>
                        <option value="168">7d</option>
                    </select>
                </div>
            </header>
            <div class="chart-container"><canvas id="chart-severity"></canvas></div>
        </section>
        <section class="chart-card">
            <h3>Top Sources</h3>
            <div class="chart-container"><canvas id="chart-sources"></canvas></div>
        </section>
        <section class="chart-card">
            <h3>Keyword Analysis</h3>
            <div class="chart-container"><canvas id="chart-keywords"></canvas></div>
        </section>
        <section class="chart-card full-span">
            <h3>Severity Over Time</h3>
            <div class="chart-container chart-wide"><canvas id="chart-severity-trend"></canvas></div>
        </section>
    </div>

    <!-- Events Table -->
    <section class="panel">
        <header class="panel-header">
            <div>
                <h2>Recent Events</h2>
                <p class="muted">Displaying last 200 events</p>
            </div>
            <div class="table-actions">
                <button class="btn-secondary" onclick="prevPage()">‚Üê Prev</button>
                <span id="pageIndicator" class="page-indicator">Page 1</span>
                <button class="btn-secondary" onclick="nextPage()">Next ‚Üí</button>
            </div>
        </header>
        <div class="table-controls">
            <label>Sort by:
                <select id="sortField">
                    <option value="time">Time</option>
                    <option value="level">Level</option>
                    <option value="source">Source</option>
                </select>
            </label>
            <label>Order:
                <select id="sortDir">
                    <option value="desc">Newest First</option>
                    <option value="asc">Oldest First</option>
                </select>
            </label>
        </div>
        <div class="table-container">
            <table class="data-table" id="eventsTable">
                <thead>
                    <tr>
                        <th>Timestamp</th>
                        <th>Log Type</th>
                        <th>Level</th>
                        <th>Source</th>
                        <th>Message</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="eventsBody">
                    <tr><td colspan="5" class="loading">Loading events...</td></tr>
                </tbody>
            </table>
        </div>
    </section>

    <!-- AI Feedback History Section -->
    <section class="panel ai-feedback-panel">
        <header class="panel-header">
            <div>
                <h2>AI Feedback History</h2>
                <p class="muted">Previously analyzed events with AI-generated explanations</p>
            </div>
            <div class="feedback-filters">
                <label>Status:
                    <select id="feedbackStatusFilter">
                        <option value="">All</option>
                        <option value="Pending">Pending</option>
                        <option value="Viewed" selected>Viewed</option>
                        <option value="Resolved">Resolved</option>
                    </select>
                </label>
                <button class="btn-secondary" onclick="refreshFeedback()">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="23 4 23 10 17 10"/>
                        <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"/>
                    </svg>
                    Refresh
                </button>
            </div>
        </header>
        <div id="feedbackList" class="feedback-list">
            <p class="loading">Loading AI feedback history...</p>
        </div>
    </section>

    <!-- AI Modal for Trend Analysis -->
    <div id="ai-modal" class="modal hidden">
        <div class="modal-content">
            <header class="modal-header">
                <h3>AI Trend Analysis</h3>
                <button class="modal-close" onclick="closeAIModal()">&times;</button>
            </header>
            <div id="ai-modal-body" class="modal-body">
                <p class="loading">Analyzing...</p>
            </div>
        </div>
    </div>
</section>

<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js" crossorigin="anonymous"></script>
<script>
let chartSeverity, chartSources, chartKeywords, chartSeverityTrend;
let currentEvents = [];
let currentPage = 1;
let rangeHours = 24;

// Get selected log types
function getSelectedLogTypes() {
    const logTypes = [];
    if (document.getElementById('logTypeApplication').checked) logTypes.push('Application');
    if (document.getElementById('logTypeSecurity').checked) logTypes.push('Security');
    if (document.getElementById('logTypeSystem').checked) logTypes.push('System');
    return logTypes;
}

// Build query string with log types
function buildLogTypesQuery() {
    const logTypes = getSelectedLogTypes();
    // If no log types selected, don't send parameter (backend defaults to all three)
    // If some selected, send those specific ones
    return logTypes.length > 0 ? `&log_types=${logTypes.join(',')}`  : '';
}

const chartColors = {
    error: '#ef4444',
    warning: '#f59e0b',
    info: '#3b82f6',
    default: '#6366f1'
};

const chartOptions = {
    responsive: true,
    maintainAspectRatio: false,
    plugins: { 
        legend: { display: false }
    },
    scales: {
        y: { 
            beginAtZero: true, 
            grid: { color: 'rgba(255,255,255,0.05)' }, 
            ticks: { color: '#94a3b8' } 
        },
        x: { 
            grid: { color: 'rgba(255,255,255,0.05)' }, 
            ticks: { color: '#94a3b8' } 
        }
    }
};

function formatTime(value) {
    if (!value) return '--';
    const dt = new Date(value);
    // Format in EST timezone
    return dt.toLocaleString('en-US', { timeZone: 'America/New_York', hour12: false });
}

async function loadSummary() {
    const logTypesQuery = buildLogTypesQuery();
    const res = await fetch(`/api/events/summary?max=500&since_hours=${rangeHours}${logTypesQuery}`);
    const data = await res.json();
    updateSourceBanner(data.source);
    document.getElementById('stat-total').textContent = data.total || 0;
    document.getElementById('stat-auth').textContent = data.keyword_counts?.auth ?? 0;
    document.getElementById('stat-disk').textContent = data.keyword_counts?.disk ?? 0;
    document.getElementById('stat-net').textContent = data.keyword_counts?.network ?? 0;

    const sevLabelsRaw = Object.keys(data.severity_counts || {});
    const sevValuesRaw = sevLabelsRaw.map(k => data.severity_counts[k]);
    const sevLabels = sevLabelsRaw.length ? sevLabelsRaw : ['No data'];
    const sevValues = sevValuesRaw.length ? sevValuesRaw : [0];
    renderBar('severity', sevLabels, sevValues, 'Events');

    const srcLabelsRaw = (data.sources_top || []).map(x => x.key);
    const srcValuesRaw = (data.sources_top || []).map(x => x.count);
    const srcLabels = srcLabelsRaw.length ? srcLabelsRaw : ['No data'];
    const srcValues = srcValuesRaw.length ? srcValuesRaw : [0];
    renderBar('sources', srcLabels, srcValues, 'Events');

    const kwLabelsRaw = Object.keys(data.keyword_counts || {});
    const kwValuesRaw = kwLabelsRaw.map(k => data.keyword_counts[k]);
    const kwLabels = kwLabelsRaw.length ? kwLabelsRaw : ['No data'];
    const kwValues = kwValuesRaw.length ? kwValuesRaw : [0];
    renderBar('keywords', kwLabels, kwValues, 'Hits');

    // Process severity timeline data for the "Severity Over Time" histogram
    // Backend provides an array of time buckets, each with error/warning/information counts
    // This ensures the chart displays multiple time intervals, not a single aggregated value
    const trend = data.severity_timeline || [];
    console.log('[Load Summary] Severity timeline buckets:', trend.length, trend);
    
    // Convert ISO timestamp buckets to EST time labels for x-axis
    const labels = trend.map(p => p.bucket ? new Date(p.bucket).toLocaleTimeString('en-US', {timeZone: 'America/New_York', hour: '2-digit', minute:'2-digit', hour12: false}) : '');
    
    // Extract severity counts for each bucket to create three separate trend lines
    const err = trend.map(p => p.error || 0);
    const warn = trend.map(p => p.warning || 0);
    const info = trend.map(p => p.information || 0);
    
    // Render the multi-line chart with all severity levels over time
    renderLineTrend(labels, err, warn, info);
}

async function loadEvents() {
    const logTypesQuery = buildLogTypesQuery();
    const res = await fetch(`/api/events?max=200&page=${currentPage}&since_hours=${rangeHours}${logTypesQuery}`);
    const data = await res.json();
    currentEvents = data.events || [];
    updateSourceBanner(data.source);
    renderTable();
    updatePageIndicator();
}

function renderTable() {
    const tbody = document.getElementById('eventsBody');
    const search = document.getElementById('searchInput').value.toLowerCase();
    const level = document.getElementById('levelFilter').value;
    const sortField = document.getElementById('sortField').value;
    const sortDir = document.getElementById('sortDir').value;

    let filtered = currentEvents;
    if (search) {
        filtered = filtered.filter(e =>
            (e.message && e.message.toLowerCase().includes(search)) ||
            (e.source && e.source.toLowerCase().includes(search))
        );
    }
    if (level) {
        filtered = filtered.filter(e => (e.level || '').toLowerCase().includes(level.toLowerCase()));
    }

    filtered = filtered.slice().sort((a, b) => {
        const dir = sortDir === 'asc' ? 1 : -1;
        if (sortField === 'time') {
            return (new Date(a.time || 0).getTime() - new Date(b.time || 0).getTime()) * dir;
        }
        if (sortField === 'level') {
            return (a.level || '').localeCompare(b.level || '') * dir;
        }
        if (sortField === 'source') {
            return (a.source || '').localeCompare(b.source || '') * dir;
        }
        return 0;
    });

    if (filtered.length === 0) {
        tbody.innerHTML = '<tr><td colspan="5" class="empty">No events found matching your criteria</td></tr>';
        return;
    }

    tbody.innerHTML = filtered.map((e, index) => {
        const levelClass = (e.level || 'info').toLowerCase();
        const logType = e.log_type || '';
        const logTypeBadge = logType ? `<span class="badge badge-log-type">${logType}</span>` : '--';
        // Get the original index in currentEvents array for Ask AI functionality
        const originalIndex = currentEvents.indexOf(e);
        return `
            <tr>
                <td>${formatTime(e.time)}</td>
                <td>${logTypeBadge}</td>
                <td><span class="badge badge-${levelClass}">${e.level || 'Info'}</span></td>
                <td>${e.source || '--'}</td>
                <td class="wrap">${e.message || ''}</td>
                <td>
                    <button class="btn-ask-ai" onclick="askAI(${originalIndex})" 
                            title="Ask AI to explain this event">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="10"/>
                            <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/>
                            <line x1="12" y1="17" x2="12.01" y2="17"/>
                        </svg>
                        Ask AI
                    </button>
                </td>
            </tr>
        `;
    }).join('');
}

function renderBar(key, labels, values, label) {
    const ctx = document.getElementById(`chart-${key}`).getContext('2d');
    if (key === 'severity' && chartSeverity) chartSeverity.destroy();
    if (key === 'sources' && chartSources) chartSources.destroy();
    if (key === 'keywords' && chartKeywords) chartKeywords.destroy();

    const colors = labels.map(l => {
        const lower = l.toLowerCase();
        if (lower.includes('error') || lower.includes('critical')) return chartColors.error;
        if (lower.includes('warn')) return chartColors.warning;
        if (lower.includes('info')) return chartColors.info;
        return chartColors.default;
    });

    const config = {
        type: 'bar',
        data: { labels, datasets: [{ label, data: values, backgroundColor: colors }] },
        options: chartOptions
    };

    if (key === 'severity') chartSeverity = new Chart(ctx, config);
    if (key === 'sources') chartSources = new Chart(ctx, config);
    if (key === 'keywords') chartKeywords = new Chart(ctx, config);
}

/**
 * Render the Severity Over Time line chart with multiple time buckets
 * Displays three severity levels (Error, Warning, Information) as separate lines
 * Each data point represents the count of events in that severity level for a specific hour
 * 
 * @param {string[]} labels - Array of formatted time labels for x-axis (e.g., "14:00", "15:00")
 * @param {number[]} errData - Array of error event counts per time bucket
 * @param {number[]} warnData - Array of warning event counts per time bucket
 * @param {number[]} infoData - Array of information event counts per time bucket
 */
function renderLineTrend(labels, errData, warnData, infoData) {
    const ctx = document.getElementById('chart-severity-trend').getContext('2d');
    
    // Destroy existing chart instance to prevent memory leaks
    if (chartSeverityTrend) chartSeverityTrend.destroy();
    
    // Create new multi-line chart with three severity datasets
    chartSeverityTrend = new Chart(ctx, {
        type: 'line',
        data: {
            labels,  // Time bucket labels on x-axis
            datasets: [
                // Error severity line - red color
                { label: 'Error', data: errData, borderColor: chartColors.error, backgroundColor: 'rgba(239,68,68,0.1)', fill: true, tension: 0.3 },
                // Warning severity line - orange color
                { label: 'Warning', data: warnData, borderColor: chartColors.warning, backgroundColor: 'rgba(245,158,11,0.1)', fill: true, tension: 0.3 },
                // Information severity line - blue color
                { label: 'Information', data: infoData, borderColor: chartColors.info, backgroundColor: 'rgba(59,130,246,0.1)', fill: true, tension: 0.3 }
            ]
        },
        options: {
            ...chartOptions,
            plugins: { legend: { position: 'top', labels: { color: '#94a3b8', usePointStyle: true } } }
        }
    });
}

function updateSourceBanner(source) {
    const banner = document.getElementById('data-source');
    if (!banner) return;
    banner.classList.remove('hidden');
    if (source === 'windows') {
        banner.textContent = '‚úì Connected to Windows Event Log';
        banner.className = 'info-banner ok';
    } else if (source === 'mock') {
        banner.textContent = '‚Ñπ Using demo data (non-Windows environment)';
        banner.className = 'info-banner warn';
    } else if (source === 'error') {
        banner.textContent = '‚ö† Failed to read events';
        banner.className = 'info-banner warn';
    } else {
        banner.className = 'info-banner hidden';
    }
}

function refreshEvents() {
    currentPage = 1;
    loadSummary();
    loadEvents();
}

function nextPage() {
    currentPage += 1;
    loadEvents();
}

function prevPage() {
    if (currentPage > 1) {
        currentPage -= 1;
        loadEvents();
    }
}

function updatePageIndicator() {
    const el = document.getElementById('pageIndicator');
    if (el) el.textContent = `Page ${currentPage}`;
}

// Helper function to escape HTML entities
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Ask AI functionality for individual Windows Event Log entries
// This provides AI-powered explanations and resolution suggestions for specific events
async function askAI(eventIndex) {
    // Validate event index and retrieve event data from stored array
    if (eventIndex < 0 || eventIndex >= currentEvents.length) {
        console.error('Invalid event index:', eventIndex);
        return;
    }
    
    const event = currentEvents[eventIndex];
    const eventData = {
        time: event.time || '',
        level: event.level || '',
        source: event.source || '',
        message: event.message || '',
        log_type: event.log_type || '',
        id: event.id || ''
    };
    
    // Log AI request for observability
    console.log('[Ask AI] Requesting explanation for event:', {
        index: eventIndex,
        log_type: eventData.log_type,
        level: eventData.level,
        source: eventData.source
    });
    
    // Show modal with loading state
    const modal = document.getElementById('ai-modal');
    const modalBody = document.getElementById('ai-modal-body');
    modal.classList.remove('hidden');
    modalBody.innerHTML = '<p class="loading">üîÑ Analyzing event with AI...</p>';
    
    try {
        // Send event data to AI explain endpoint for analysis
        const response = await fetch('/api/ai/explain', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                type: 'windows_event',
                context: eventData,
                userQuestion: `Explain this Windows ${eventData.log_type || 'Event'} Log entry. What does it mean, what could have caused it, and what should I do about it?`
            })
        });
        
        const result = await response.json();
        
        // Log response for observability
        console.log('[Ask AI] Received response:', { 
            success: !result.error,
            severity: result.severity
        });
        
        if (result.error) {
            // Display error message if AI request failed
            modalBody.innerHTML = `<p class="error">‚ö†Ô∏è ${escapeHtml(result.error)}</p>`;
        } else {
            // Render AI explanation with severity badge and recommended actions
            let severityBadge = '';
            if (result.severity === 'critical') {
                severityBadge = '<span class="badge badge-error">Critical</span>';
            } else if (result.severity === 'warning') {
                severityBadge = '<span class="badge badge-warning">Warning</span>';
            } else {
                severityBadge = '<span class="badge badge-info">Info</span>';
            }
            
            modalBody.innerHTML = `
                <div class="ai-response">
                    <div class="ai-severity">${severityBadge}</div>
                    <div class="event-details">
                        <strong>${escapeHtml(eventData.source || 'Unknown Source')}</strong>
                        ${eventData.id ? `<span class="event-id">(Event ID: ${escapeHtml(eventData.id)})</span>` : ''}
                        <span class="badge badge-${(eventData.level || 'info').toLowerCase()}">${escapeHtml(eventData.level || 'Info')}</span>
                    </div>
                    <div class="ai-explanation">${result.explanationHtml}</div>
                    ${result.recommendedActions && result.recommendedActions.length > 0 ? `
                        <div class="ai-actions">
                            <h4>Recommended Actions:</h4>
                            <ul>
                                ${result.recommendedActions.map(a => `<li>${a}</li>`).join('')}
                            </ul>
                        </div>
                    ` : ''}
                </div>
            `;
            
            // Save AI feedback to backend for persistent storage
            // Default status is 'Viewed' as user has seen this explanation
            saveFeedbackToBackend(eventData, result.explanationHtml);
        }
    } catch (error) {
        // Log and display error if request fails
        console.error('[Ask AI] Request failed:', error);
        modalBody.innerHTML = `<p class="error">‚ö†Ô∏è Failed to get AI explanation: ${error.message}</p>`;
    }
}

// Analyze Trends functionality for events
// Performs cross-log-type trend analysis when multiple log types are selected
// or single log type analysis for focused insights
async function analyzeTrends() {
    // Log trend analysis request for observability
    console.log('[Analyze Trends] Starting trend analysis');
    
    // Show modal
    const modal = document.getElementById('ai-modal');
    const modalBody = document.getElementById('ai-modal-body');
    modal.classList.remove('hidden');
    
    const selectedLogTypes = getSelectedLogTypes();
    
    // Log selected configuration for debugging
    console.log('[Analyze Trends] Configuration:', {
        logTypes: selectedLogTypes,
        rangeHours: rangeHours,
        crossReference: selectedLogTypes.length === 3
    });
    
    try {
        let events = [];
        let analysisMessage = '';
        
        // Check if all three log types are selected for cross-referencing
        if (selectedLogTypes.length === 3 && 
            selectedLogTypes.includes('Application') && 
            selectedLogTypes.includes('Security') && 
            selectedLogTypes.includes('System')) {
            
            // Fetch 100 events from each log type for cross-referencing
            modalBody.innerHTML = '<p class="loading">üîÑ Fetching 100 events from each log type for cross-reference analysis...</p>';
            
            const applicationResponse = await fetch(`/api/events?max=100&since_hours=${rangeHours}&log_types=Application`);
            const securityResponse = await fetch(`/api/events?max=100&since_hours=${rangeHours}&log_types=Security`);
            const systemResponse = await fetch(`/api/events?max=100&since_hours=${rangeHours}&log_types=System`);
            
            const appData = await applicationResponse.json();
            const secData = await securityResponse.json();
            const sysData = await systemResponse.json();
            
            // Combine all events (log_type already set by backend)
            events = [
                ...(appData.events || []),
                ...(secData.events || []),
                ...(sysData.events || [])
            ];
            
            // Sort by time descending
            events.sort((a, b) => new Date(b.time || 0) - new Date(a.time || 0));
            
            analysisMessage = `Analyze these ${events.length} Windows events from Application (${appData.events?.length || 0}), Security (${secData.events?.length || 0}), and System (${sysData.events?.length || 0}) logs. Cross-reference events across log types to identify correlated issues, security incidents with corresponding system errors, or application failures related to system events. Focus on patterns that span multiple log types and indicate systemic problems.`;
            
        } else {
            // Fetch up to 100 events from selected log types
            const logTypesQuery = buildLogTypesQuery();
            modalBody.innerHTML = '<p class="loading">üîÑ Analyzing last 100 events for trends...</p>';
            
            const response = await fetch(`/api/events?max=100&since_hours=${rangeHours}${logTypesQuery}`);
            const data = await response.json();
            events = data.events || [];
            
            const logTypeList = selectedLogTypes.join(', ');
            analysisMessage = `Analyze these ${events.length} Windows events from ${logTypeList} log(s) for trends, recurring issues, or anything that needs immediate attention. Focus on identifying patterns that could indicate problems.`;
        }
        
        if (events.length === 0) {
            modalBody.innerHTML = '<p class="error">‚ö†Ô∏è No events available to analyze.</p>';
            return;
        }
        
        modalBody.innerHTML = '<p class="loading">üîÑ Analyzing events with AI...</p>';
        
        // Prepare context for AI analysis
        const eventsContext = events.map(event => ({
            time: event.time || '',
            level: event.level || '',
            source: event.source || '',
            message: event.message || '',
            log_type: event.log_type || ''
        }));
        
        // Send to AI for trend analysis
        const aiResponse = await fetch('/api/ai/explain', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                type: 'windows_event',
                context: {
                    analysis_type: 'trends',
                    event_count: events.length,
                    log_types: selectedLogTypes,
                    cross_reference: selectedLogTypes.length === 3,
                    events: eventsContext
                },
                userQuestion: analysisMessage
            })
        });
        
        const result = await aiResponse.json();
        
        // Log AI response for observability
        console.log('[Analyze Trends] AI response received:', {
            success: !result.error,
            severity: result.severity,
            hasActions: result.recommendedActions?.length > 0
        });
        
        if (result.error) {
            modalBody.innerHTML = `<p class="error">‚ö†Ô∏è ${escapeHtml(result.error)}</p>`;
        } else {
            let severityBadge = '';
            if (result.severity === 'critical') {
                severityBadge = '<span class="badge badge-error">Critical</span>';
            } else if (result.severity === 'warning') {
                severityBadge = '<span class="badge badge-warning">Warning</span>';
            } else {
                severityBadge = '<span class="badge badge-info">Info</span>';
            }
            
            modalBody.innerHTML = `
                <div class="ai-response">
                    <div class="ai-severity">${severityBadge}</div>
                    <h4>Trend Analysis (${events.length} events analyzed)</h4>
                    <div class="ai-explanation">${result.explanationHtml}</div>
                    ${result.recommendedActions && result.recommendedActions.length > 0 ? `
                        <div class="ai-actions">
                            <h4>Recommended Actions:</h4>
                            <ul>
                                ${result.recommendedActions.map(a => `<li>${a}</li>`).join('')}
                            </ul>
                        </div>
                    ` : ''}
                </div>
            `;
        }
    } catch (error) {
        // Log error for debugging
        console.error('[Analyze Trends] Request failed:', error);
        modalBody.innerHTML = `<p class="error">‚ö†Ô∏è Failed to analyze trends: ${error.message}</p>`;
    }
}

function closeAIModal() {
    const modal = document.getElementById('ai-modal');
    modal.classList.add('hidden');
}

// Close modal on clicking outside
document.addEventListener('click', (e) => {
    const modal = document.getElementById('ai-modal');
    if (e.target === modal) {
        closeAIModal();
    }
});

// Close modal on Escape key
document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
        closeAIModal();
    }
});

// AI Feedback Management Functions

/**
 * Save AI feedback to backend for persistent storage
 * Called after AI generates an explanation for an event
 */
async function saveFeedbackToBackend(eventData, aiResponse) {
    try {
        console.log('[Save Feedback] Saving to backend:', {
            event_id: eventData.id,
            log_type: eventData.log_type,
            source: eventData.source
        });
        
        const response = await fetch('/api/ai/feedback', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                event_id: eventData.id || null,
                event_source: eventData.source || '',
                event_message: eventData.message || '',
                event_log_type: eventData.log_type || '',
                event_level: eventData.level || '',
                event_time: eventData.time || null,
                ai_response: aiResponse,
                review_status: 'Viewed'  // Default status when user sees AI explanation
            })
        });
        
        if (!response.ok) {
            const error = await response.json();
            console.error('[Save Feedback] Failed:', error);
            return;
        }
        
        const result = await response.json();
        console.log('[Save Feedback] Saved successfully:', result.id);
        
        // Refresh the feedback list to show the new entry
        loadFeedbackHistory();
    } catch (error) {
        console.error('[Save Feedback] Error:', error);
        // Don't show error to user - feedback is supplementary feature
    }
}

/**
 * Load AI feedback history from backend
 * Displays historical AI-generated explanations with review status controls
 */
async function loadFeedbackHistory() {
    const feedbackList = document.getElementById('feedbackList');
    const statusFilter = document.getElementById('feedbackStatusFilter')?.value || '';
    
    try {
        // Build query parameters
        let url = '/api/ai/feedback?limit=20&since_days=30';
        if (statusFilter) {
            url += `&status=${statusFilter}`;
        }
        
        const response = await fetch(url);
        const data = await response.json();
        
        console.log('[Load Feedback] Retrieved:', data.total, 'entries');
        
        if (data.error) {
            feedbackList.innerHTML = `<p class="error">‚ö†Ô∏è ${escapeHtml(data.error)}</p>`;
            return;
        }
        
        if (!data.feedback || data.feedback.length === 0) {
            feedbackList.innerHTML = '<p class="empty-state">No AI feedback history available. Use "Ask AI" to analyze events.</p>';
            return;
        }
        
        // Render feedback entries
        const html = data.feedback.map(entry => {
            const statusClass = entry.review_status.toLowerCase();
            const levelClass = (entry.event_level || 'info').toLowerCase();
            
            return `
                <article class="feedback-entry">
                    <header class="feedback-header">
                        <div class="feedback-event-info">
                            <strong>${escapeHtml(entry.event_source || 'Unknown Source')}</strong>
                            ${entry.event_id ? `<span class="event-id">(Event ID: ${entry.event_id})</span>` : ''}
                            <span class="badge badge-${levelClass}">${escapeHtml(entry.event_level || 'Info')}</span>
                            ${entry.event_log_type ? `<span class="badge badge-log-type">${escapeHtml(entry.event_log_type)}</span>` : ''}
                        </div>
                        <div class="feedback-meta">
                            <span class="feedback-date">${formatTime(entry.created_at)}</span>
                            <select class="status-selector status-${statusClass}" 
                                    data-feedback-id="${entry.id}"
                                    onchange="updateFeedbackStatus(${entry.id}, this.value)">
                                <option value="Pending" ${entry.review_status === 'Pending' ? 'selected' : ''}>‚è≥ Pending</option>
                                <option value="Viewed" ${entry.review_status === 'Viewed' ? 'selected' : ''}>üëÅÔ∏è Viewed</option>
                                <option value="Resolved" ${entry.review_status === 'Resolved' ? 'selected' : ''}>‚úÖ Resolved</option>
                            </select>
                        </div>
                    </header>
                    <div class="feedback-event-message">
                        <strong>Event:</strong> ${escapeHtml(entry.event_message?.substring(0, 200) || '')}${entry.event_message?.length > 200 ? '...' : ''}
                    </div>
                    <div class="feedback-ai-response">
                        <strong>AI Analysis:</strong>
                        <div class="ai-explanation-text">${entry.ai_response}</div>
                    </div>
                </article>
            `;
        }).join('');
        
        feedbackList.innerHTML = html;
        
    } catch (error) {
        console.error('[Load Feedback] Error:', error);
        feedbackList.innerHTML = `<p class="error">‚ö†Ô∏è Failed to load feedback history: ${error.message}</p>`;
    }
}

/**
 * Update the review status of an AI feedback entry
 * Called when user changes status dropdown
 */
async function updateFeedbackStatus(feedbackId, newStatus) {
    try {
        console.log('[Update Status] Updating feedback', feedbackId, 'to', newStatus);
        
        const response = await fetch(`/api/ai/feedback/${feedbackId}/status`, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                status: newStatus
            })
        });
        
        if (!response.ok) {
            const error = await response.json();
            console.error('[Update Status] Failed:', error);
            alert('Failed to update status: ' + (error.error || 'Unknown error'));
            // Reload to reset the dropdown
            loadFeedbackHistory();
            return;
        }
        
        const result = await response.json();
        console.log('[Update Status] Updated successfully:', result);
        
        // Update the dropdown styling to reflect new status
        const selector = document.querySelector(`select[data-feedback-id="${feedbackId}"]`);
        if (selector) {
            selector.className = `status-selector status-${newStatus.toLowerCase()}`;
        }
        
    } catch (error) {
        console.error('[Update Status] Error:', error);
        alert('Failed to update status: ' + error.message);
        loadFeedbackHistory();
    }
}

/**
 * Refresh the feedback history list
 */
function refreshFeedback() {
    loadFeedbackHistory();
}

document.getElementById('analyzeTrendsBtn').addEventListener('click', analyzeTrends);
document.getElementById('refreshBtn').addEventListener('click', refreshEvents);
document.getElementById('searchInput').addEventListener('input', renderTable);
document.getElementById('levelFilter').addEventListener('change', renderTable);
document.getElementById('sortField').addEventListener('change', renderTable);
document.getElementById('sortDir').addEventListener('change', renderTable);
document.getElementById('rangeHours').addEventListener('change', (e) => {
    rangeHours = Number(e.target.value) || 24;
    currentPage = 1;
    refreshEvents();
});

// Add event listeners for log type checkboxes
document.getElementById('logTypeApplication').addEventListener('change', () => {
    currentPage = 1;
    refreshEvents();
});
document.getElementById('logTypeSecurity').addEventListener('change', () => {
    currentPage = 1;
    refreshEvents();
});
document.getElementById('logTypeSystem').addEventListener('change', () => {
    currentPage = 1;
    refreshEvents();
});

// Add event listener for feedback status filter
document.getElementById('feedbackStatusFilter')?.addEventListener('change', () => {
    loadFeedbackHistory();
});

// Load both events and feedback history on page load
document.addEventListener('DOMContentLoaded', () => {
    refreshEvents();
    loadFeedbackHistory();
});
</script>

<style>
.page-container {
    max-width: 1600px;
    margin: 0 auto;
}

/* Log Type Filter Styles */
.log-type-filter {
    display: flex;
    align-items: center;
    gap: 1.5rem;
    padding: 1rem;
    background: var(--bg-elevated, #182038);
    border: 1px solid var(--border-default, #2a3553);
    border-radius: 8px;
    margin-bottom: 1.5rem;
}

.log-type-label {
    font-weight: 600;
    color: var(--text-primary, #e5e7eb);
    font-size: 0.95rem;
    margin: 0;
}

.checkbox-label {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    cursor: pointer;
    color: var(--text-secondary, #94a3b8);
    font-size: 0.9rem;
    user-select: none;
    transition: color 0.2s ease;
}

.checkbox-label:hover {
    color: var(--text-primary, #e5e7eb);
}

.checkbox-label input[type="checkbox"] {
    cursor: pointer;
    width: 18px;
    height: 18px;
    accent-color: #10b981;
}

.checkbox-label span {
    padding-top: 1px;
}

.btn-analyze-trends {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.6rem 1rem;
    font-size: 0.9rem;
    font-weight: 600;
    color: #fff;
    background: linear-gradient(135deg, #10b981, #059669);
    border: 1px solid #10b981;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 2px 4px rgba(16, 185, 129, 0.2);
}

.btn-analyze-trends:hover {
    background: linear-gradient(135deg, #059669, #047857);
    border-color: #34d399;
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
}

.btn-analyze-trends svg {
    flex-shrink: 0;
}

/* Modal Styles */
.modal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.7);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    padding: 1rem;
}

.modal.hidden {
    display: none;
}

.modal-content {
    background: #12182a;
    border: 1px solid #2a3553;
    border-radius: 12px;
    max-width: 700px;
    width: 100%;
    max-height: 80vh;
    overflow: hidden;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
}

.modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1rem 1.25rem;
    background: #182038;
    border-bottom: 1px solid #2a3553;
}

.modal-header h3 {
    margin: 0;
    font-size: 1.1rem;
    color: #e5e7eb;
}

.modal-close {
    background: none;
    border: none;
    color: #94a3b8;
    font-size: 1.5rem;
    cursor: pointer;
    padding: 0;
    line-height: 1;
}

.modal-close:hover {
    color: #e5e7eb;
}

.modal-body {
    padding: 1.25rem;
    overflow-y: auto;
    max-height: calc(80vh - 60px);
}

.ai-response {
    color: #e5e7eb;
}

.ai-severity {
    margin-bottom: 1rem;
}

.ai-explanation {
    line-height: 1.6;
}

.ai-explanation p {
    margin: 0.75rem 0;
}

.ai-explanation h4 {
    margin: 1rem 0 0.5rem;
    font-size: 0.95rem;
    color: #c7d2fe;
}

.ai-actions {
    margin-top: 1rem;
    padding-top: 1rem;
    border-top: 1px solid #2a3553;
}

.ai-actions h4 {
    margin: 0 0 0.5rem;
    font-size: 0.9rem;
    color: #94a3b8;
}

.ai-actions ul {
    margin: 0;
    padding-left: 1.25rem;
}

.ai-actions li {
    margin: 0.25rem 0;
}

.loading {
    color: #94a3b8;
    font-style: italic;
}

.error {
    color: #fca5a5;
}

/* Badge styles */
.badge-error {
    background: #dc2626;
    color: #fee;
}

.badge-warning {
    background: #f59e0b;
    color: #fef3c7;
}

.badge-info {
    background: #1e3a8a;
    color: #c7d2fe;
}

.badge-log-type {
    background: #6366f1;
    color: #e0e7ff;
    font-size: 0.75rem;
    padding: 0.25rem 0.5rem;
    border-radius: 4px;
    font-weight: 500;
}

.chart-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--space-md);
}

.chart-header h3 {
    margin: 0;
}

.range-selector select {
    padding: var(--space-xs) var(--space-sm);
    background: var(--bg-elevated);
    border: 1px solid var(--border-default);
    border-radius: var(--radius-sm);
    color: var(--text-primary);
    font-size: 0.85rem;
}

/* Ask AI button styles */
.btn-ask-ai {
    display: inline-flex;
    align-items: center;
    gap: 0.35rem;
    padding: 0.4rem 0.65rem;
    font-size: 0.8rem;
    font-weight: 500;
    color: #fff;
    background: linear-gradient(135deg, #8b5cf6, #7c3aed);
    border: 1px solid #8b5cf6;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s ease;
    white-space: nowrap;
}

.btn-ask-ai:hover {
    background: linear-gradient(135deg, #7c3aed, #6d28d9);
    border-color: #a78bfa;
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(139, 92, 246, 0.3);
}

.btn-ask-ai svg {
    flex-shrink: 0;
}

/* Event details in AI modal */
.event-details {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 1rem;
    padding: 0.75rem;
    background: rgba(139, 92, 246, 0.1);
    border-radius: 6px;
    border-left: 3px solid #8b5cf6;
}

.event-details strong {
    color: #c7d2fe;
}

.event-id {
    color: #94a3b8;
    font-size: 0.85rem;
    font-family: monospace;
}

.chart-container {
    position: relative;
    height: 200px;
}

.chart-wide {
    height: 250px;
}

.panel-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--space-md);
    padding-bottom: var(--space-sm);
    border-bottom: 1px solid var(--border-subtle);
}

.panel-header h2 {
    margin: 0;
    border: none;
    padding: 0;
}

.table-actions {
    display: flex;
    gap: var(--space-sm);
    align-items: center;
}

.page-indicator {
    padding: var(--space-xs) var(--space-md);
    background: var(--bg-elevated);
    border-radius: var(--radius-sm);
    font-size: 0.85rem;
    color: var(--text-secondary);
}

.table-controls {
    display: flex;
    gap: 1rem;
    align-items: center;
    margin: 0.5rem 0 0.75rem 0;
}

.table-controls label {
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    color: var(--text-secondary);
    font-size: 0.9rem;
}

.table-controls select {
    padding: 0.5rem;
    border: 1px solid var(--border-default);
    border-radius: 6px;
    background: var(--bg-elevated);
    color: var(--text-primary);
}

.table-container {
    overflow-x: auto;
}

/* AI Feedback History Styles */
.ai-feedback-panel {
    margin-top: 2rem;
}

.feedback-filters {
    display: flex;
    gap: 1rem;
    align-items: center;
}

.feedback-filters label {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    color: var(--text-secondary);
    font-size: 0.9rem;
}

.feedback-filters select {
    padding: 0.5rem;
    border: 1px solid var(--border-default);
    border-radius: 6px;
    background: var(--bg-elevated);
    color: var(--text-primary);
}

.feedback-list {
    display: flex;
    flex-direction: column;
    gap: 1rem;
}

.feedback-entry {
    background: var(--bg-elevated, #182038);
    border: 1px solid var(--border-default, #2a3553);
    border-radius: 8px;
    padding: 1rem;
    transition: all 0.2s ease;
}

.feedback-entry:hover {
    border-color: #3b4a6b;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
}

.feedback-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 0.75rem;
    gap: 1rem;
}

.feedback-event-info {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    flex-wrap: wrap;
    flex: 1;
}

.feedback-event-info strong {
    color: var(--text-primary, #e5e7eb);
    font-size: 0.95rem;
}

.feedback-meta {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    flex-shrink: 0;
}

.feedback-date {
    color: var(--text-secondary, #94a3b8);
    font-size: 0.85rem;
    white-space: nowrap;
}

.status-selector {
    padding: 0.4rem 0.75rem;
    border-radius: 6px;
    border: 1px solid;
    font-size: 0.85rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    min-width: 120px;
}

.status-selector:hover {
    transform: translateY(-1px);
}

.status-pending {
    background: rgba(251, 191, 36, 0.1);
    border-color: #fbbf24;
    color: #fef3c7;
}

.status-viewed {
    background: rgba(59, 130, 246, 0.1);
    border-color: #3b82f6;
    color: #bfdbfe;
}

.status-resolved {
    background: rgba(16, 185, 129, 0.1);
    border-color: #10b981;
    color: #d1fae5;
}

.feedback-event-message {
    margin-bottom: 0.75rem;
    padding: 0.75rem;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 6px;
    color: var(--text-secondary, #94a3b8);
    font-size: 0.9rem;
    line-height: 1.5;
}

.feedback-event-message strong {
    color: var(--text-primary, #e5e7eb);
    margin-right: 0.5rem;
}

.feedback-ai-response {
    padding: 0.75rem;
    background: rgba(139, 92, 246, 0.05);
    border-left: 3px solid #8b5cf6;
    border-radius: 4px;
}

.feedback-ai-response strong {
    display: block;
    color: #c7d2fe;
    margin-bottom: 0.5rem;
    font-size: 0.9rem;
}

.ai-explanation-text {
    color: var(--text-secondary, #94a3b8);
    font-size: 0.9rem;
    line-height: 1.6;
}

.ai-explanation-text p {
    margin: 0.5rem 0;
}

.empty-state {
    text-align: center;
    padding: 2rem;
    color: var(--text-secondary, #94a3b8);
    font-style: italic;
}
</style>
{% endblock %}
